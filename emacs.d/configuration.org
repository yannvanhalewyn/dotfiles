* General emacs stuff
** Load path

   Add "emacs.d/config" to the load path for extra functions and custom packages.

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (concat user-emacs-directory "config"))
   #+END_SRC

** Load utility functions

   Load a generous collection of custom utility functions

   #+BEGIN_SRC emacs-lisp
     (require 'init-functions)
   #+END_SRC

** Custom.el

   Set up a different cutom file for ~custom.el~ so we don't have to check in all those random automatically added code snippets.

   #+BEGIN_SRC emacs-lisp
     (defconst custom-file (expand-file-name "custom.el" user-emacs-directory))
     (unless (file-exists-p custom-file)
       (write-region "" nil custom-file))
     (load custom-file)
   #+END_SRC

** Garbage collection

   Allow 20MB of memory (instead of 0.76MB) before calling garbage collection. This means GC runs less often, which speeds up some operations.

   #+BEGIN_SRC emacs-lisp
     (setq gc-cons-threshold 0)
     (setq gc-cons-percentage 0.3)
   #+END_SRC

** Hide splash screen

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC

** Silence bell

   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC

** Just type y or n

   #+BEGIN_SRC emacs-lisp
     (defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC

** No backup files

   Emacs will create annoying backup ~#file.txt#~ and lock ~file.txt~~
   files while editing. This is more annoying than useful since we all
   use version control.

   #+BEGIN_SRC emacs-lisp
     (setq make-backup-files nil)
     (setq create-lockfiles nil)
     (auto-save-mode nil)
   #+END_SRC

** Deal with temp files

   #+BEGIN_SRC emacs-lisp
     (setq backup-directory-alist `((".*" . ,temporary-file-directory)))
     (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
   #+END_SRC

** Add brews and /usr/local/bin to exec path

   [[https://github.com/purcell/exec-path-from-shell][Exec path from shell]] was a bit slow. This gives me what I need for now.

   #+BEGIN_SRC emacs-lisp
     (let ((paths "/Users/yannvanhalewyn/.rbenv/shims:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/MacGPG2/bin"))
       (setenv "PATH" paths)
       (setq eshell-path-env paths))
     (add-to-list 'exec-path "/usr/local/bin")
   #+END_SRC

** Save minibuffer history

   #+BEGIN_SRC emacs-lisp
     (require 'savehist)
     (savehist-mode t)
   #+END_SRC

** Quitting minibuffer with ESC

   Make ESC quit various types of minibuffers. Without this you need 3 esc hits to quit them.

   #+BEGIN_SRC emacs-lisp
     (defun minibuffer-keyboard-quit ()
       "Abort recursive edit.
     In Delete Selection mode, if the mark is active, just deactivate it;
     then it takes a second \\[keyboard-quit] to abort the minibuffer."
       (interactive)
       (if (and delete-selection-mode transient-mark-mode mark-active)
           (setq deactivate-mark  t)
         (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
         (abort-recursive-edit)))
     (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
     (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
     (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
     (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
     (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
   #+END_SRC

** Setup emacs macport

   Make alt-key work as meta, and disable tab bar

   #+BEGIN_SRC emacs-lisp
     (when (eq (window-system) 'mac)
       (setq mac-option-modifier 'meta)
       (setq mac-command-modifier 'super)
       (setq mac-pass-command-to-system t)
       (mac-set-frame-tab-group-property nil :tab-bar-visible-p nil))
   #+END_SRC

** Winner mode

   Easily navigate window configurations history (bound to ~[w~ and ~]w~)

   #+BEGIN_SRC emacs-lisp
     (when (fboundp 'winner-mode)
       (winner-mode 1))
   #+END_SRC

** Initial frame size

   Default initial frame size is pretty weird. This will open emacs in
   a more comfortable position and size.

   #+BEGIN_SRC emacs-lisp
     (defun yvh/set-frame-size (&optional base-factor)
       (let* ((factor (or base-factor 0.7))
              (width (display-pixel-width))
              (height (display-pixel-height))
              (left (truncate (* width (- 1 factor) 0.5)))
              (top (truncate (* height (- 1 factor) 0.5))))
         (set-frame-position (selected-frame) left top)
         (set-frame-size (selected-frame) (truncate (* width factor))  (truncate (* height factor)) t)))

     (when (window-system)
       (add-hook 'after-init-hook 'yvh/set-frame-size))
   #+END_SRC

** User email adress

   #+BEGIN_EXAMPLE emacs-lisp
     (setq user-mail-address "yann.vanhalewyn@gmail.com")
   #+END_EXAMPLE

** Package manager

  Set up ~package.el~ and point it to stable melpa repositories.

  #+BEGIN_SRC emacs-lisp
    (require 'package)

    (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                             ("marmalade" . "https://marmalade-repo.org/packages/")
                             ("melpa" . "https://melpa.org/packages/")
                             ("melpa-stable" .  "http://stable.melpa.org/packages/")
                             ("org" . "https://orgmode.org/elpa/")))

    (package-initialize)
  #+END_SRC

  Install ~use-package~

  #+BEGIN_SRC emacs-lisp
    (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))

    (eval-when-compile
      (require 'use-package))

    (setq use-package-verbose nil
          use-package-always-ensure t)
  #+END_SRC

* Buffers
** Auto newlines at end of buffer

   #+BEGIN_SRC emacs-lisp
     (setq require-final-newline t)
   #+END_SRC

** Warn when opening large files

   #+BEGIN_SRC emacs-lisp
     (setq large-file-warning-threshold 100000000)
   #+END_SRC

** Auto clear trailing whitespace

   Removes trailing whitespace when buffer saves.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'before-save-hook 'delete-trailing-whitespace)
   #+END_SRC

** Auto revert buffers when changes on file system

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode t)
   #+END_SRC

** Auto save buffer when leaving insert mode

   #+BEGIN_SRC emacs-lisp
     (defun save-if-code-buffer ()
       (when (buffer-file-name) (save-buffer)))

     (defun set-save-hook! ()
       (interactive)
       (add-hook 'evil-insert-state-exit-hook 'save-if-code-buffer))

     (defun clear-save-hook! ()
       (interactive)
       (remove-hook 'evil-insert-state-exit-hook 'save-if-code-buffer))

     (set-save-hook!)
   #+END_SRC

** Prevent ~# -*- coding: utf-8 -*-~

   #+BEGIN_SRC emacs-lisp
     (setq ruby-insert-encoding-magic-comment nil)
   #+END_SRC

** Indentation

   Prefer spaces over tabs

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

   Set indentations for various languages

   #+BEGIN_SRC emacs-lisp
     (setq js-indent-level 2
           css-indent-offset 2
           c-basic-offset 4
           python-indent 2)
   #+END_SRC

   Set default indentation, when file contains tabs be displayed as 2 spaces instead of 8

   #+BEGIN_SRC emacs-lisp
     (setq-default tab-width 2)
   #+END_SRC

** Remember cursor position when opening files

   #+BEGIN_SRC emacs-lisp
     (setq save-place-file (locate-user-emacs-file "places"))
     (setq-default save-place t)
     (require 'saveplace)
     (save-place-mode 1)
   #+END_SRC

** Always follow symlinks

   #+BEGIN_SRC emacs-lisp
     (setq vc-follow-symlinks t)
   #+END_SRC

** Centering after jumping paragraphs

   #+BEGIN_SRC emacs-lisp
     (setq scroll-margin 3
           scroll-conservatively 9999
           scroll-step 1)
   #+END_SRC

** Don't confirm when creating new file

   #+BEGIN_SRC emacs-lisp
     (setq confirm-nonexistent-file-or-buffer nil)
   #+END_SRC

** Scroll in compilation mode

   #+BEGIN_SRC emacs-lisp
     (setq compilation-scroll-output t)
   #+END_SRC

** C++ header files

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
   #+END_SRC

** Open common config files with conf mode

   #+BEGIN_SRC emacs-lisp
     (let* ((conf-files '("aliases" "functions" "gitignore" "rc" ".tf" "Dockerfile"))
            (conf-regexp (concat (regexp-opt conf-files t) "\\'")))
       (add-to-list 'auto-mode-alist (cons conf-regexp 'conf-mode)))
   #+END_SRC

** Get colorized compilation buffers

   Useful for various test runners that use compilation buffers, like the mocha test runner.

   #+BEGIN_SRC emacs-lisp
     (require 'ansi-color)
     (defun colorize-compilation-buffer ()
       (toggle-read-only)
       (ansi-color-apply-on-region compilation-filter-start (point))
       (toggle-read-only))
     (add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
   #+END_SRC

** Allow to erase buffers without warning

   This is useful for clearing the shell buffer without emacs complaining.

   #+BEGIN_SRC emacs-lisp
     (put 'erase-buffer 'disabled nil)
   #+END_SRC

* Layout
** Setup theme and font

   #+BEGIN_SRC emacs-lisp
     (use-package kaolin-themes :init (load-theme 'kaolin-galaxy t))
     (set-face-attribute 'default nil :font "Menlo" :height 145)
   #+END_SRC

** Use rich icons

   Have pretty icons for neotree and the modeline. Be sure to run ~M-x all-the-icons-install-fonts~
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons)
   #+END_SRC

** Setup modeline

   [[https://github.com/seagle0128/doom-modeline][DOOM modeline]] is the modeline from DOOM emacs and is beautiful with lots of great features.

   Custom package used for my modeline:

   - [[https://github.com/yannvanhalewyn/dotfiles/blob/master/emacs.d/config/ci-status.el][ci-status]] fetches the current status from CI using hub

   #+BEGIN_SRC emacs-lisp
     (use-package doom-modeline
       :ensure t
       :hook (after-init . doom-modeline-mode)
       :config
       (column-number-mode) ;; Show column number in modeline
       (setq doom-modeline-height 25
             doom-modeline-percent-position nil
             column-number-indicator-zero-based nil)

       (require 'ci-status)
       (add-hook 'magit-status-mode-hook 'cis/update)
       (doom-modeline-def-segment ci-status
         (when (cis/has-status?)
           (let ((status (format "CI %s  " (cis/propertized-status cis/latest-ci-status))))
             (if (doom-modeline--active) status
               (propertize status 'face 'mode-line-inactive)))))

       (doom-modeline-def-modeline 'yvh/modeline
         '(bar matches buffer-info remote-host buffer-position selection-info)
         '(misc-info minor-modes major-mode process vcs checker ci-status))

       (defun yvh/setup-default-modeline ()
         (doom-modeline-set-modeline 'yvh/modeline 'default))
       (add-hook 'doom-modeline-mode-hook 'yvh/setup-default-modeline))
   #+END_SRC

** Highlight current line

   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode t)
   #+END_SRC

** Show matching paren

   This is a must when editing lisps.

   #+BEGIN_SRC emacs-lisp
     (show-paren-mode 1)
   #+END_SRC

   Make sure the matching paren has an aPARENt apparent

   #+BEGIN_SRC emacs-lisp
     (custom-set-faces
      '(show-paren-match ((t (:background "#0E9E97" :weight bold)))))
   #+END_SRC

** Interface

   Hide menu bar

   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode 0)
   #+END_SRC

   Hide toolbar, scroll bars and setup smaller fringe in GUI version

   #+BEGIN_SRC emacs-lisp
     (when window-system
       (scroll-bar-mode -1)
       (tool-bar-mode -1)
       (fringe-mode 10))
   #+END_SRC

* Packages
** Diminish

   Hides some modes from the modeline. Included for integration with ~use-package~.

   #+BEGIN_SRC emacs-lisp
     (use-package diminish)
   #+END_SRC

** General (keybindings)

   [[https://github.com/noctuid/general.el][General.el]] is an amazing tool to manage keybindings. It can create definers with prefixes, which are a great replacement for evil-leader.

   #+BEGIN_SRC emacs-lisp
     (use-package general
       :config
       (setq default-states '(normal emacs motion))
       (general-define-key :states 'motion "SPC" nil)
       (general-create-definer keys-l :prefix "SPC" :states default-states)
       (general-create-definer keys :states default-states))
   #+END_SRC

   Setup global keybindings

   #+BEGIN_SRC emacs-lisp
     (keys :states 'insert "C-i" 'insert-char)
     (keys
       "M-x" 'counsel-M-x
       "C-=" 'text-scale-increase
       "C--" 'text-scale-decrease
       "[e" 'flycheck-previous-error
       "]e" 'flycheck-next-error
       "]t" 'yvh/cycle-theme
       "]f" 'yvh/next-file-in-dir
       "[f" 'yvh/prev-file-in-dir
       "[w" 'winner-undo
       "]w" 'winner-redo
       "[b" 'yvh/previous-code-buffer
       "]b" 'yvh/next-code-buffer
       "|"  'yvh/transpose-windows
       "<s-return>" 'toggle-frame-fullscreen)

     (keys :states '(visual motion)
       "RET" 'align-regexp)
    #+END_SRC

   Setup global 'goto' 'g bindings

   #+BEGIN_SRC emacs-lisp
     (keys :prefix "g"
       "t" (yvh/find-file-i 'gtd-main)
       "i" (yvh/find-file-i 'gtd-inbox)
       "s" (yvh/find-file-i 'gtd-someday)
       "h" (yvh/find-file-i "~/Google Drive/Documents/timesheet.org"))
   #+END_SRC

   Global leaders for evaluating emacs-lisp code

   #+BEGIN_SRC emacs-lisp
     (keys-l :keymaps '(emacs-lisp-mode-map scheme-mode-map)
       "e" 'eval-defun
       "E" 'eval-buffer)
   #+END_SRC

   Global leader keys

   #+BEGIN_SRC emacs-lisp
     (keys-l
       "a" (yvh/build-keymap
            "a" 'org-agenda
            "t" 'org-todo-list
            "c" '(lambda () (interactive) (org-capture nil "t"))
            "f" 'org-tags-view
            "C" 'quick-calc)
       "B" 'ibuffer
       "b" 'ivy-switch-buffer
       "c" (yvh/build-keymap
            "u" 'cis/update
            "o" 'cis/open-ci-build
            "t" 'yvh/comment-as-title
            "T" 'yvh/comment-as-title--bm)
       "d" 'yvh/dired-current-dir
       "D" 'yvh/dired-project-root
       "f" (yvh/build-keymap
            "f" 'counsel-projectile-find-file
            "r" 'counsel-recentf
            "m" 'yvh/rename-current-buffer-file
            "c" 'yvh/copy-current-buffer-file
            "d" 'yvh/delete-current-buffer-file
            "s" 'save-buffer
            "S" 'save-some-buffers
            "j" 'junk-file/find)
       "v" (yvh/build-keymap
            "f" (yvh/find-file-i (locate-user-emacs-file "config/init-functions.el"))
            "p" (yvh/find-file-i (locate-user-emacs-file "configuration.org")))
       "h" (yvh/build-keymap
            "a" 'counsel-apropos
            "f" 'describe-function
            "K" 'which-key-show-top-level
            "k" 'describe-key
            "m" 'describe-mode
            "p" 'describe-package
            "v" 'describe-variable)
       "m" 'mu4e
       "o" 'counsel-find-file
       "Q" 'delete-other-windows
       "q" 'kill-this-buffer
       "R" 'yvh/chrome-reload
       "S" 'shell
       "w" 'yvh/buff-swap
       "x" 'counsel-projectile-ag
       "X" 'ag)
  #+END_SRC

** Dired

   #+BEGIN_SRC emacs-lisp
     (require 'dired)
   #+END_SRC

   Kill dired buffer when quitting

   #+BEGIN_SRC emacs-lisp
     (keys :keymaps 'dired-mode-map
       "q" 'kill-this-buffer
       "y" 'dired-copy-filename-as-kill
       "w" 'wdired-change-to-wdired-mode)
   #+END_SRC

   Enable leader keys in dired mode.

   #+BEGIN_SRC emacs-lisp
     (general-def dired-mode-map "SPC" nil)
   #+END_SRC

   DWIM: Do What I Mean. Setting this to a non nil value will automatically fill copy / move targets with the working directory of another dired buffer.

   #+BEGIN_SRC emacs-lisp
   (setq dired-dwim-target t)
   #+END_SRC

   Human readable units

   #+BEGIN_SRC emacs-lisp
     (setq-default dired-listing-switches "-alh")
   #+END_SRC

   Sort listings by directories first

   #+BEGIN_SRC emacs-lisp
     (defun yvh/sort-dired-listings-by-directory ()
       "Sort dired listings with directories first."
       (save-excursion
         (let (buffer-read-only)
           (forward-line 2) ;; beyond dir. header
           (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
         (set-buffer-modified-p nil)))

     (defadvice dired-readin
         (after dired-after-updating-hook first () activate)
       "Sort dired listings with directories first before adding marks."
       (yvh/sort-dired-listings-by-directory))
   #+END_SRC

** iBuffer

   Setup better filtering groups

   #+BEGIN_SRC emacs-lisp
     (setq ibuffer-saved-filter-groups
           (quote (("default"
                    ("code" (or (mode . clojure-mode)
                                (mode . clojurec-mode)
                                (mode . c-mode)
                                (mode . ruby-mode)
                                (mode . javascript-mode)
                                (mode . java-mode)
                                (mode . js-mode)
                                (mode . clojurescript-mode)))
                    ("emacs" (or (name . "^\\*scratch\\*$")
                                 (name . "^\\*Messages\\*$")
                                 (name . "^\\*Completions\\*$")))
                    ("configs" (or (mode . emacs-lisp-mode)
                                   (mode . org-mode)
                                   (mode . conf-mode)))
                    ("Magit" (name . "magit"))
                    ("Help" (or (name . "\*Help\*")
                                (name . "\*Apropos\*")
                                (name . "\*info\*")))
                    ("tmp" (or (mode . dired-mode)
                               (name ."^\\*")))))))

     (setq ibuffer-show-empty-filter-groups nil)

     (add-hook 'ibuffer-mode-hook
               (lambda ()
                 (ibuffer-switch-to-saved-filter-groups "default")))
   #+END_SRC

** Evil
*** Evil Mode

    What would we do without [[https://github.com/emacs-evil/evil][Evil]]

    #+BEGIN_SRC emacs-lisp
      (use-package evil
        :init
        (setq evil-want-fine-undo t)
        :config
        (evil-mode t)

        (evil-add-hjkl-bindings package-menu-mode-map 'emacs)
        (evil-add-hjkl-bindings ibuffer-mode-map 'emacs)

        (keys
          "C-h" 'evil-window-left
          "C-j" 'evil-window-down
          "C-k" 'evil-window-up
          "C-l" 'evil-window-right
          "j"   'evil-next-visual-line
          "k"   'evil-previous-visual-line)

        (keys :states 'insert
          "C-y" 'yank))
    #+END_SRC

    Grab - and _ as part of the word (more vim-like)

    #+BEGIN_SRC emacs-lisp
      (add-hook 'prog-mode-hook
                (lambda ()
                  (modify-syntax-entry ?_ "w")
                  (modify-syntax-entry ?- "w")))
    #+END_SRC

*** Evil NerdCommenter

    Easy commenting as a vi motion

    #+BEGIN_SRC emacs-lisp
      (use-package evil-nerd-commenter
        :diminish evil-commentary-mode
        :init
        (keys "gc" 'evilnc-comment-operator)
        (keys-l
          "c y" 'evilnc-copy-and-comment-lines))
    #+END_SRC

*** Evil Surround

    Like TPope's [[https://github.com/tpope/vim-surround][Surround]], but for evil.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-surround
        :config (global-evil-surround-mode 1))
    #+END_SRC

*** Evil Cleverparens

    [[https://github.com/luxbock/evil-cleverparens][Evil Cleverparens]] for editing lisps in evil. Especially makes sure killing and yanking lines don't include unmatched parens + easy surrounding expressions with ~M-[~ and ~M-(~.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-cleverparens
        :defer t
        :diminish evil-cleverparens-mode
        :config
        ;; Evil CP overwrites "c" for change. This will re-enable "cs"
        ;; motion "change surrounding" of evil-surround
        (evil-cp--enable-surround-operators)
        :init
        ;; Don't use crazy bindings for {, [, } and ] from evil-cleverparens
        (setq evil-cleverparens-use-additional-movement-keys nil))
    #+END_SRC

*** Evil Numbers

    Who doesn't love vim's c-a and c-x for incrementing and decrementing numbers.

    #+BEGIN_SRC emacs-lisp
      (use-package evil-numbers
        :defer t
        :init
        (keys :prefix "g"
          "a" 'evil-numbers/inc-at-pt
          "x" 'evil-numbers/dec-at-pt))
    #+END_SRC

*** Evil Iedit

    [[https://github.com/syl20bnr/evil-iedit-state][Evil Iedit]] is a sort of multiple cursor that works well with Evil mode

    #+BEGIN_SRC emacs-lisp
      (use-package evil-iedit-state
        :commands (evil-iedit-state evil-iedit-state/iedit-mode)
        :init (keys-l "s i" 'evil-iedit-state/iedit-mode))
    #+END_SRC
** Magit

   The killer app for Emacs. Seriously.

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :defer t
       :init
       (keys-l "g" (yvh/build-keymap
                    "b" 'magit-blame
                    "c" 'magit-checkout
                    "C" 'magit-branch-and-checkout
                    "d" 'vc-diff
                    "D" 'magit-diff
                    "f" 'magit-find-file
                    "F" 'magit-pull-from-pushremote
                    "l" 'magit-log-head
                    "L" 'magit-log-popup
                    "m" 'magit-merge
                    "M" 'magit-merge-popup
                    "o" 'git-link
                    "p" 'magit-push-current-to-pushremote
                    "P" 'yvh/force-push-with-lease
                    "r" (yvh/build-keymap
                         "a" 'magit-rebase-abort
                         "c" 'magit-rebase-continue
                         "i" 'magit-rebase-interactive
                         "r" 'magit-rebase
                         "s" 'magit-rebase-skip)
                    "s" 'magit-status
                    "S" 'magit-stash))

       :config
       (use-package evil-magit)
       (add-hook 'git-commit-mode-hook 'evil-insert-state)
       ;; Refresh VC state for modeline when magit refreshes
       (add-hook 'magit-refresh-buffer-hook 'vc-refresh-state)

       ;; Enable leader keys in revision buffers
       (general-def magit-revision-mode-map "SPC" nil)
       (general-def magit-status-mode-map "SPC" nil)

       (setq magit-diff-refine-hunk t)
       (keys :keymaps '(magit-revision-mode-map diff-mode-map magit-status-mode-map)
         :states 'visual
         "y" 'yvh/yank-from-revision-buffer)
       (keys 'magit-blame-mode-map
         "q" 'magit-blame-quit
         "|" 'magit-blame-cycle-style)
       (keys 'git-rebase-mode-map "q" 'magit-rebase-abort)
       (keys 'magit-status-mode-map "K" 'magit-discard)
       (general-def 'transient-map        "q" 'transient-quit-one)
       (general-def 'transient-edit-map   "q" 'transient-quit-one)
       (general-def 'transient-sticky-map "q" 'transient-quit-seq))
   #+END_SRC

** Git link

   Easily get github urls for commits, lines or regions in files

   #+BEGIN_SRC emacs-lisp
     (use-package git-link
       :defer t
       :config (setq git-link-open-in-browser t))
   #+END_SRC

** Company (autocompletion)

   [[https://github.com/company-mode/company-mode][Company Mode]] is a great autocompletion frontend for Emacs. It will
   hook into various completion systems automatically. This config will
   enable the `tng` frontend, which stands for "tab 'n go". The
   default will select the first candidate and close the list. This
   frontend it will complete the first candidate when pressing tab,
   but will keep other candidates in the popup so you can keep
   cycling. Pressing return or any other key will stop the completion.

   #+BEGIN_SRC emacs-lisp
     (use-package company
       :diminish company-mode
       :init (global-company-mode)
       :config
       (setq company-idle-delay 0
             company-require-match nil
             company-frontends '(company-tng-frontend
                                 company-pseudo-tooltip-frontend
                                 company-echo-metadata-frontend))
       (general-def 'company-active-map
         "<tab>" 'company-select-next
         "S-<tab>" 'company-select-previous
         "RET" 'company-complete
         "C-h" nil
         "C-d" 'company-show-doc-buffer
         "C-s" 'company-filter-candidates
         "C-n" 'company-select-next
         "C-p" 'company-select-previous))
   #+END_SRC

** Yasnippet

   #+BEGIN_SRC emacs-lisp
     (use-package yasnippet
       :diminish yas-minor-mode
       :config
       (yas-global-mode 1)
       ;; Fill $0 with selected region when using yas-insert-snippet.
       (setq yas-wrap-around-region t
             yas-snippet-dirs '("~/.emacs.d/snippets"))
       (keys :states '(insert)
         "M-<tab>" 'yas-expand)
       (keys-l "i u" 'yas-insert-snippet))
    #+END_SRC

** Ace jump

   Jump to anywhere with double SPC

   #+BEGIN_SRC emacs-lisp
     (use-package ace-jump-mode
       :defer t
       :init
       (keys-l
         "SPC" 'ace-jump-mode
         "S-SPC" 'ace-jump-char-mode))
    #+END_SRC

** Smart jump

   Smart jump uses multiple backends for jumping to definitions of
   symbols at point. It falls back to dumb-jump by default when no
   other jumpers are available.

   #+BEGIN_SRC emacs-lisp
     (use-package smart-jump
       :commands (smart-jump smart-jump-go)
       :init
       (keys "<M-.>" 'smart-jump-go
             "<M-,>" 'smart-jump-back)
       :config
       (smart-jump-setup-default-registers))
   #+END_SRC

** Undo-tree

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :diminish undo-tree-mode
       :config (global-undo-tree-mode t))
   #+END_SRC

** Which-key

   Display available keybindings in popup

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :diminish which-key-mode
       :config
       (which-key-mode +1)
       (setq which-key-idle-delay 0.5)
       (which-key-setup-side-window-bottom)
       (which-key-add-key-based-replacements
         "SPC a" "Applications"
         "SPC c" "Cider / CI / Comment"
         "SPC f" "Files"
         "SPC g" "Git"
         "SPC g r" "Rebase"
         "SPC h" "Help"
         "SPC i" "Insert"
         "SPC p" "Project"
         "SPC s" "Sexp / Shell"
         "SPC v" "View configuration"))
    #+END_SRC

** Ruby/Rails
*** Basic web modes

    #+BEGIN_SRC emacs-lisp
      (use-package haml-mode :defer t)
      (use-package yaml-mode :defer t)
      (use-package css-mode :defer t)
      (use-package sass-mode :defer t)
      (use-package scss-mode :defer t)
    #+END_SRC

*** projectile-rails

    #+BEGIN_SRC emacs-lisp
      (use-package projectile-rails
        :defer t
        :init
        (keys :prefix "g"
          :keymaps  'ruby-mode-map
          "r" 'projectile-rails-find-current-controller
          "R" 'projectile-rails-find-controller
          "f" 'projectile-rails-goto-file-at-point
          "m" 'projectile-rails-find-current-model
          "M" 'projectile-rails-find-model
          "v" 'projectile-rails-find-current-view
          "V" 'projectile-rails-find-view
          "i" 'open-current-ticket-in-redmine
          "t" 'split-window-with-rspec-alternate-file
          "T" 'projectile-rails-find-spec)
        :config
        ;; Won't start unless rails project
        (add-hook 'projectile-mode-hook 'projectile-rails-on))
    #+END_SRC

*** Rspec

    Running rspec tests from the editor

    #+BEGIN_SRC emacs-lisp
      (use-package rspec-mode
        :defer t
        :init
        (eval-after-load 'rspec-mode '(rspec-install-snippets))
        (keys-l :keymaps 'ruby-mode-map
          "t" 'rspec-verify
          "a" 'rspec-verify-all
          "s" 'rspec-verify-single
          "l" 'rspec-rerun))
    #+END_SRC

*** Prettier

    Ensure consistent js formatting

    #+BEGIN_SRC emacs-lisp
      (use-package prettier-js
        :defer t
        :config
        (setq prettier-js-args '("--trailing-comma" "all"))
        :init
        (yhv/add-hooks #'prettier-js-mode '(js2-mode-hook js-mode-hook)))
   #+END_SRC

*** Inf ruby

    Using pry in rspec buffers

    #+BEGIN_SRC emacs-lisp
      (use-package inf-ruby
        :defer t
        :init
        (add-hook 'ruby-mode-hook 'inf-ruby-switch-setup))
   #+END_SRC

*** Smartparens

    Balance parentheses, brackets and quotes in c, ruby, js, .. and
    close do-end blocks in ruby. Also insert an extra newline when
    pressing return after a bracket.

    #+BEGIN_SRC emacs-lisp
      (use-package smartparens
        :defer t
        :init
        (yhv/add-hooks #'smartparens-mode '(ruby-mode-hook js-mode-hook c-mode-common-hook rust-mode-hook))
        :config
        (require 'smartparens-ruby)
        (dolist (mode '(c++-mode 'c-mode 'js-mode 'js2-mode 'glsl-mode
                                 'java-mode 'java-mode 'rust-mode 'ruby-mode))
          (sp-local-pair mode "{" nil :post-handlers '((yvh/newline-in-sexp "RET")))
          (sp-local-pair mode "(" nil :post-handlers '((yvh/newline-in-sexp "RET")))
          (sp-local-pair mode "[" nil :post-handlers '((yvh/newline-in-sexp "RET")))))
    #+END_SRC

** Flycheck (linting)

   [[https://github.com/flycheck/flycheck/][Flycheck]] is a nice on-the-fly linter and synthax checking framework for emacs that comes with many backends.

   For the clojure setup, be sure to check out [[https://github.com/clojure-emacs/squiggly-clojure][Squiggly Clojure]], which uses a combination of [[https://github.com/jonase/eastwood][Eastwood]], [[https://github.com/jonase/kibit][Kibit]] and [[http://typedclojure.org/][core.typed]] via a Cider connection for efficiently linting files. Make sure to have these dependencies in your ~~/.lein/profiles.clj~:

   #+BEGIN_SRC clojure
     {:user {:dependencies [[acyclic/squiggly-clojure "0.1.9-SNAPSHOT"
                             :exclusions [org.clojure/tools.reader]]]
             :plugins [[jonase/eastwood "0.2.9"]
                       [lein-kibit "0.1.6"]
                       [cider/cider-nrepl "0.18.0"]]
             ;; I personally don't use core.typed, hence the exclusion here.
             :env {:squiggly {:checkers [:eastwood :kibit]}}}}
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :diminish flycheck-mode
       :defer t
       :init
       (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc clojure-cider-typed))
       (add-hook 'after-init-hook #'global-flycheck-mode)

       :config
       (use-package flycheck-clojure
         :defer t
         :init
         (eval-after-load 'flycheck '(flycheck-clojure-setup)))

       (use-package flycheck-popup-tip
         :defer t
         :init
         (with-eval-after-load 'flycheck
           (flycheck-popup-tip-mode)))

       (setq flycheck-check-syntax-automatically '(save mode-enabled))
       (add-hook 'c++-mode-hook
                 (lambda ()
                   (setq flycheck-gcc-language-standard "c++14")
                   (setq flycheck-clang-language-standard "c++14"))))
    #+END_SRC

** Clojure
*** Clojure mode

    Initialize clojure mode and setup some useful minor modes for editing those lisps.

    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :diminish eldoc-mode
        :defer t
        :init
        (defun parainbow-mode ()
          (interactive)
          (paredit-mode)
          (evil-cleverparens-mode)
          (rainbow-delimiters-mode)
          (eldoc-mode t))

        (yhv/add-hooks #'parainbow-mode '(clojure-mode-hook
                                          scheme-mode
                                          clojurescript-mode-hook
                                          cider-repl-mode-hook
                                          emacs-lisp-mode-hook))
        :config
        (setq clojure-indent-style :always-align)
        (dolist (word '(try-let assoc-if transform match facts fact assoc render for-all))
          (put-clojure-indent word 1)))
    #+END_SRC

*** Cider

    Interactive repl and more

    #+BEGIN_SRC emacs-lisp
      (use-package cider
        :defer t
        :config
        (setq cider-repl-display-help-banner nil
              cider-repl-pop-to-buffer-on-connect 'display-only)

        (defvar cider-mode-maps
          '(cider-repl-mode-map
            clojure-mode-map
            clojurescript-mode-map))

        (defun reset-dev-system ()
          (interactive)
          (message "Running `(reset)` in current repl")
          (cider-interactive-eval "(dev/reset)"))

        (defun cider-evil-eval-last-sexp ()
          "Just like `cider-evail-last-sexp`, but useful in evil mode where
           you cant move past the ending of the line. It will eval the last
           s-expression up until including the evil point."
          (interactive)
          (save-excursion
            (forward-char)
            (cider-eval-last-sexp)))

        (keys cider-repl-mode-map
          "q" 'delete-window)

        (general-def cider-repl-mode-map
          "<up>" 'cider-repl-backward-input
          "<down>" 'cider-repl-forward-input
          "<return>" 'cider-repl-return
          "<S-return>" 'cider-repl-newline-and-indent)

        (keys cider-inspector-mode-map
          "<return>" 'cider-inspector-operate-on-point
          "q" 'cider-inspector-pop
          "[p" 'cider-inspector-prev-page
          "]p" 'cider-inspector-next-page)

        (keys cider-stacktrace-mode-map
          "C-j" 'cider-stacktrace-next-cause
          "C-k" 'cider-stacktrace-previous-cause
          "TAB" 'cider-stacktrace-cycle-current-cause
          "A"   'cider-stacktrace-toggle-all
          "C"   'cider-stacktrace-toggle-clj
          "D"   'cider-stacktrace-toggle-duplicates
          "J"   'cider-stacktrace-toggle-java
          "R"   'cider-stacktrace-toggle-repl
          "T"   'cider-stacktrace-toggle-tooling
          "q"   'cider-popup-buffer-quit)

        (keys cider-test-report-mode-map
          "C-j" 'cider-test-next-result
          "C-k" 'cider-test-previous-result
          "d"   'cider-test-ediff
          "r"   'cider-test-rerun-test
          "s"   'cider-test-stacktrace
          "q"   'cider-popup-buffer-quit)

        (keys (cider-browse-spec-mode-map
               cider-browse-spec-view-mode-map
               cider-browse-spec-example-mode-map)
          "TAB" 'cider-browse-spec--print-curr-spec-example)

        (keys :keymaps cider-mode-maps "g f" 'cider-find-var)

        (keys-l :keymaps cider-mode-maps
          "c" (yvh/build-keymap
               "a" 'cider-apropos
               "e" 'cider-read-and-eval
               "s" 'cider-browse-spec
               "c" 'yvh/cider-connect-local
               "d" 'cider-doc
               "i" 'cider-inspect-last-result
               "j" 'cider-jack-in
               "k" 'cider-repl-clear-buffer
               "m" 'cider-macro-expand-1
               "n" 'cider-repl-set-ns
               "q" 'cider-quit
               "r" 'yvh/jump-to-repl
               "R" 'reset-dev-system
               "m" 'cider-macroexpand-1
               "M" 'cider-macroexpand-all)
          "e" 'cider-eval-last-sexp
          "E" 'cider-eval-buffer
          "t" (yvh/build-keymap
               "s" 'cider-test-run-test
               "t" 'cider-test-run-ns-tests
               "f" 'cider-test-rerun-failed-tests
               "l" 'cider-test-rerun-test
               "a" 'cider-test-run-project-tests
               "A" 'cider-auto-test-mode)))
    #+END_SRC

*** Eval Sexp Fu

    [[https://github.com/emacsmirror/eval-sexp-fu][Eval Sexp Fu]] highlights (flashes) what region is being evaluated for some visual feedback.

    #+BEGIN_SRC emacs-lisp
      (use-package eval-sexp-fu
        :config
        (set-face-attribute 'eval-sexp-fu-flash nil
                            :background (face-attribute 'success :foreground)
                            :foreground "#292b2e")
        (set-face-attribute 'eval-sexp-fu-flash-error nil
                            :background (face-attribute 'error :foreground)
                            :foreground "#292b2e")

        (setq eval-sexp-fu-flash-duration 0.1)

        (use-package cider-eval-sexp-fu))
    #+END_SRC

*** Clj Refactor

    Amazing refactoring utils for clojure

    #+BEGIN_SRC emacs-lisp
      (use-package clj-refactor
        :defer t
        :init
        (yhv/add-hooks #'clj-refactor-mode '(clojure-mode-hook clojurescript-mode-hook))
        :config
        (let ((cljr-map (make-sparse-keymap)))
          (dolist (details cljr--all-helpers)
            (define-key cljr-map (car details) (cadr details)))
          (keys-l :keymaps 'clojure-mode-map
            "r" cljr-map)))
    #+END_SRC

*** Rainbow Delimiters

    #+BEGIN_SRC emacs-lisp
      (use-package rainbow-delimiters :defer t)
    #+END_SRC

*** Paredit

    [[https://www.emacswiki.org/emacs/ParEdit][Paredit]] allows for performing structured editing of S-expression
    data (lisps). Especially useful for slurping and barfing
    parentheses.

    #+BEGIN_SRC emacs-lisp
      (use-package paredit
        :defer t
        :diminish paredit-mode
        :init
        (keys paredit-mode-map
          ")" 'paredit-forward-slurp-sexp
          "(" 'paredit-forward-barf-sexp
          "C-(" 'paredit-backward-slurp-sexp
          "C-)" 'paredit-backward-barf-sexp)
        (keys-l "s c" 'paredit-convolute-sexp))
    #+END_SRC

*** Aggressive Indent

    Enforce consistent indentation, beautiful in lisps

    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
        :defer t
        :diminish aggressive-indent-mode
        :init
        (yhv/add-hooks #'aggressive-indent-mode '(clojure-mode-hook
                                              emacs-lisp-mode-hook
                                              clojurescript-mode-hook)))
    #+END_SRC

** Java
*** Company intellisense completion

    Meghanada is an all-round IDE package for java development. It
    integrates with Company mode completions and flycheck linting. It
    starts a dev server in the background automatically.

    #+BEGIN_SRC emacs-lisp
      (use-package meghanada
        :defer t
        :init

        (add-hook 'java-mode-hook
                  (lambda ()
                    (meghanada-mode t)
                    ;; (setq c-basic-offset 2)
                    ;; Now calls this before every save hook, even in non java files..
                    ;; (add-hook 'before-save-hook 'meghanada-code-beautify-before-save)
                    ))

        :config
        (setq meghanada-java-path "java"
              meghanada-maven-path "mvn"))
    #+END_SRC

** Project Management
*** Projectile

    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :diminish projectile-mode
        :config
        (projectile-global-mode)
        (setq projectile-require-project-root nil
              projectile-switch-project-action 'counsel-projectile-find-file)
        (define-key projectile-command-map (kbd "C") 'projectile-compile-project)
        (define-key projectile-command-map (kbd "c") 'recompile)
        (keys-l
          "p" 'projectile-command-map
          "p T" 'yvh/view-test-file-in-other-window)

        (projectile-register-project-type 'clojure '("project.clj")
                                          :test-suffix "_test")

        ;; Projectile-ag
        (use-package ag
          :defer t
          :init (setq ag-reuse-buffers t)))
     #+END_SRC

*** Neotree

    Navigate en manage file tree in sidebar

    #+BEGIN_SRC emacs-lisp
      (use-package neotree
        :defer t
        :init (keys-l "n" 'yvh/neotree-project-root)
        :config
        (evil-make-overriding-map neotree-mode-map 'normal t)
        (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
        (keys 'neotree-mode-map
          "d" 'neotree-delete-node
          "J" 'neotree-select-down-node
          "K" 'neotree-select-up-node
          "q" 'neotree-hide
          "m" 'neotree-rename-node
          "n" 'neotree-create-node
          "c" 'neotree-copy-node
          "o" 'neotree-enter
          "x" (lambda () (interactive) (neotree-select-up-node) (neotree-enter))
          "<tab>" 'neotree-quick-look))
    #+END_SRC

*** Ivy

    Ivy is an amazing generic completion frontend. Ivy mode will
    automatically open most common minibuffer completion dialogs in
    it's frontend.

    #+BEGIN_SRC emacs-lisp
      (use-package ivy
        :init
        ;; better scoring / result sorting
        (use-package flx)
        :diminish ivy-mode
        :config
        (ivy-mode)
        (setq ivy-re-builders-alist '((swiper . ivy--regex-plus)
                                      (counsel-ag . ivy--regex)
                                      (t . ivy--regex-fuzzy))
              completing-read-function 'yvh/ivy-completing-read-with-symbol-def)

        (general-def ivy-minibuffer-map
          "<escape>" 'minibuffer-keyboard-quit
          "<tab>" 'ivy-alt-done
          "S-<tab>" 'ivy-insert-current
          "S-<return>" '(lambda () (interactive) (ivy-alt-done t))
          "C-o" 'ivy-occur)

        ;; Enable leader keys in occur buffer
        (general-def ivy-occur-grep-mode-map "SPC" nil)

        (defun yvh/ivy-yank-action (x) (kill-new x))
        (defun yvh/ivy-projectile-delete-action (x) (delete-file (projectile-expand-root x)))
        (ivy-set-actions 'counsel-projectile-find-file '(("d" yvh/ivy-projectile-delete-action "delete")
                                                         ("y" yvh/ivy-yank-action "yank")))

        (use-package swiper
          :defer t
          :config (keys "/" 'swiper))

        (use-package counsel-projectile
          :init
          ;; Currently there is a breaking change in projectile. Until the fix is merged, this patches it:
          ;; https://github.com/ericdanan/counsel-projectile/pull/92
          (setq projectile-keymap-prefix (where-is-internal 'projectile-command-map nil t))
          :config
          (keys-l "p p" 'counsel-projectile-switch-project))

        (use-package wgrep :defer t))
   #+END_SRC
** Markdown

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :defer t
       :ensure t
       :commands (markdown-mode gfm-mode)
       :mode (("README\\.md\\'" . gfm-mode)
              ("\\.md\\'" . markdown-mode)
              ("\\.markdown\\'" . markdown-mode))
       :init (setq markdown-command "multimarkdown"))
   #+END_SRC

** Org

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :defer t
       :init
       (keys-l 'org-mode-map
         "r" 'org-refile
         "A" 'org-archive-subtree-default-with-confirmation
         "i l" 'org-insert-link)

       (keys 'org-mode-map
         "t" 'org-todo
         "T" 'org-toggle-checkbox
         "-" 'org-cycle-list-bullet
         "RET" 'org-open-at-point
         "<S-return>" 'org-edit-special)

       ;; Override company complete and yas expand snippet
       (keys 'org-mode-map :states 'insert
         "<tab>" 'org-cycle
         "S-<tab>" 'org-shifttab
         "<return>" 'org-return-indent)

       (keys 'org-agenda-mode-map
         "f" 'org-agenda-filter-by-tag)

       :config
       (defconst gtd-dir "~/Dropbox/Documents/gtd")
       (defconst gtd-main (expand-file-name "gtd.org" gtd-dir))
       (defconst gtd-inbox (expand-file-name "inbox.org" gtd-dir))
       (defconst gtd-someday (expand-file-name "someday.org" gtd-dir))

       (add-hook 'org-capture-mode-hook 'evil-insert-state)

       (add-hook 'org-mode-hook '(lambda () (interactive) (org-content 2)))

       (setq org-agenda-files `(,gtd-main ,gtd-inbox)
             org-log-done 'time
             org-html-postamble nil
             org-ellipsis "↷")

       (setq org-agenda-custom-commands
             '(("w" "Work (All)" tags-todo "@work")
               ("n" "Work (Next Actions)" tags-todo "@work"
                ((org-agenda-overriding-header "Work")
                 (org-agenda-skip-function #'yvh/org-agenda-skip-all-siblings-but-first)))))

       (setq org-capture-templates `(("t" "Todo [inbox]" entry
                                      (file ,gtd-inbox)
                                      "* TODO %i%?")))

       (setq org-refile-targets '((gtd-main :maxlevel . 1)
                                  (gtd-someday :level . 1)))

       (setq org-tags-column 75)

       (use-package org-bullets
         :defer t
         :init (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

       (add-hook 'org-mode-hook (lambda ()
                                  (push '("[ ]" . "☐") prettify-symbols-alist)
                                  (push '("[X]" . "☑" ) prettify-symbols-alist)
                                  (push '("[-]" . "❍" ) prettify-symbols-alist)
                                  (push '("#+BEGIN_SRC" . "λ") prettify-symbols-alist)
                                  (push '("#+END_SRC" . "λ") prettify-symbols-alist)
                                  (prettify-symbols-mode)))

       ;; Make checked list items look striked-through
       (defface org-checkbox-done-text
         '((t (:foreground "#71696A" :strike-through t)))
         "Face for the text part of a checked org-mode checkbox.")

       (font-lock-add-keywords
        'org-mode
        `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)"
           1 'org-checkbox-done-text prepend))
        'append)

       (use-package org-evil))
  #+END_SRC

** Org reveal.js presentations

   The following package allows you to create awesome reveal.js
   presentations from org files using org-export.

   #+BEGIN_SRC emacs-lisp
     (use-package ox-reveal
       :ensure ox-reveal
       :config
       (setq org-reveal-root "https://cdn.jsdelivr.net/reveal.js/3.0.0/"
             org-reveal-title-slide "<h2>%t</h2>  <p>%a</br>%e</p>"
             org-reveal-control nil
             org-reveal-slide-number nil))
   #+END_SRC
** Mail

   Text based email is great for quickly navigating and moving emails around. Some setup is needed, these guides are plenty helpful:

   - http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/
   - https://notanumber.io/2016-10-03/better-email-with-mu4e/


   Tried mbsync because offlineimap was slow. Set up config using:

   http://pragmaticemacs.com/emacs/migrating-from-offlineimap-to-mbsync-for-mu4e/

   But moved back to using offlineimap because isync did not support oauth2 for my work email.

   Make sure to install ~mu~ with ~EMACS=$(which emacs) brew install mu --with-emacs --HEAD~ to get the mu4e plugins. The ~EMACS~ variable is to determine the actual emacs version. Then add the package to the load path:

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu/mu4e/")
     (require 'mu4e)
     (use-package evil-mu4e)
   #+END_SRC

   Next configure it!

   #+BEGIN_SRC emacs-lisp
     (setq mail-user-agent 'mu4e-user-agent
           mu4e-contexts
           `( ,(make-mu4e-context
                :name "Gmail"
                :match-func (lambda (msg)
                              (when msg
                                (string-prefix-p "/gmail" (mu4e-message-field msg :maildir))))
                :vars '((user-mail-address . "yann.vanhalewyn@gmail.com")
                        (mu4e-compose-signature . "Met vriendelijke groeten,\n\nYann Vanhalewyn")
                        (mu4e-sent-folder . "/gmail/Sent Mail")
                        (mu4e-trash-folder . "/gmail/Bin")
                        (mu4e-refile-folder . "/gmail/All Mail")
                        (mu4e-drafts-folder . "/gmail/Drafts")
                        (mu4e-maildir-shortcuts . (("/gmail/INBOX" . ?i)
                                                   ("/gmail/All Mail" . ?a)
                                                   ("/gmail/Bin" . ?t)
                                                   ("/gmail/Sent Mail" . ?s)))))
              ,(make-mu4e-context
                :name "Brightin"
                :match-func (lambda (msg)
                              (when msg
                                (string-prefix-p "/brightin" (mu4e-message-field msg :maildir))))
                :vars '((user-mail-address . "yann@brightin.nl")
                        (mu4e-compose-signature . "Groeten,\n\nYann Vanhalewyn\nBrightmotive\n")
                        (mu4e-sent-folder . "/brightin/Sent Mail")
                        (mu4e-trash-folder . "/brightin/Trash")
                        (mu4e-refile-folder . "/brightin/All Mail")
                        (mu4e-drafts-folder . "/brightin/Drafts")
                        (mu4e-maildir-shortcuts . (("/brightin/INBOX" . ?i)
                                                   ("/brightin/All Mail" . ?a)
                                                   ("/brightin/Trash" . ?t)
                                                   ("/brightin/Sent Mail" . ?s))))))

           mu4e-maildir "~/mail"

           ;; don't save message to Sent Messages, Gmail/IMAP takes care of this
           mu4e-sent-messages-behavior 'delete
           user-full-name  "Yann Vanhalewyn"
           mu4e-get-mail-command "offlineimap -o"
           mu4e-headers-auto-update t
           ;; mu4e-update-interval 300

           mu4e-bookmarks
           `( ,(make-mu4e-bookmark
                :name  "Inbox Unread"
                :query "flag:unread AND maildir:/brightin/INBOX"
                :key ?u)
              ,(make-mu4e-bookmark
                :name "Monitoring"
                :query "flag:unread AND maildir:/brightin/INBOX AND
                        (from:Rollbar OR from:Datadog OR from:AWS)"
                :key ?m)))

     (keys 'mu4e-headers-mode-map
       ;; Hack: Delete will actually just archive it in Gmail. Being in "All
       ;; Mail" will be ineffective
       "r" 'mu4e-headers-mark-for-delete)
   #+END_SRC

   Configure sending email:

   #+BEGIN_SRC emacs-lisp
     ;; make sure the gnutls command line utils are installed
     (require 'smtpmail)
     (setq message-send-mail-function 'smtpmail-send-it
           starttls-use-gnutls t
           smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
           smtpmail-auth-credentials
           '(("smtp.gmail.com" 587 "yann-brightin" nil))
           smtpmail-default-smtp-server "smtp.gmail.com"
           smtpmail-smtp-server "smtp.gmail.com"
           smtpmail-smtp-service 587
           message-kill-buffer-on-exit t)

     (defvar my-mu4e-account-alist
       '(("yann.vanhalewyn@gmail.com"
          (user-mail-address "yann.vanhalewyn@gmail.com")
          (smtpmail-smtp-user "yann.vanhalewyn@gmail.com"))
         ("yann@brightin.nl"
          (user-mail-address "yann@brightin.nl")
          (smtpmail-smtp-user "yann@brightin.nl"))))

     (defun my-mu4e-set-account ()
       "Set the account for composing a message.
        This function is taken from:
          https://www.djcbsoftware.nl/code/mu/mu4e/Multiple-accounts.html"
       (let* ((account
               (if nil
                   (mu4e-message-field mu4e-compose-parent-message :to)
                 (completing-read (format "Compose with account: (%s) "
                                          (mapconcat #'(lambda (var) (car var))
                                                     my-mu4e-account-alist "/"))
                                  (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
                                  nil t nil nil (caar my-mu4e-account-alist))))
              (account-vars (cdr (assoc account my-mu4e-account-alist))))
         (if account-vars
             (mapc #'(lambda (var)
                       (set (car var) (cadr var)))
                   account-vars)
           (error "No email account found"))))

     (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)
   #+END_SRC

   Set up displaying html emails

   #+BEGIN_SRC emacs-lisp
     (require 'mu4e-contrib)

     (setq mu4e-html2text-command 'mu4e-shr2text
           ;; Uncomment this to use w3m to extract text from html emails
           ;; mu4e-html2text-command "w3m -dump -T text/html"
           shr-color-visible-luminance-min 80
           shr-color-visible-distance-min 5
           ;; Setting Format=Flowed for non-text-based mail clients which don’t
           ;; respect actual formatting, but let the text “flow” as they please.
           ;; Automatic line breaks when reading mail
           mu4e-compose-format-flowed t
           ;; Images, doesn't seem to work
           mu4e-view-show-images t)

     (when (fboundp 'imagemagick-register-types)
       (imagemagick-register-types))

     (add-hook 'mu4e-view-mode-hook 'visual-line-mode)
     ;; When viewing an email press "a" for actions, "V" to open the email
     ;; in a browser.
     (add-to-list 'mu4e-view-actions '("ViewInBrowser" . mu4e-action-view-in-browser) t)
   #+END_SRC

** SQL

   Add some keybindings for easier sending sql data to the SQLi buffer


   #+BEGIN_SRC emacs-lisp
     (keys-l sql-mode-map
       "e" 'sql-send-paragraph
       "E" 'sql-send-buffer)

     (general-def comint-mode-map
       "<up>" 'comint-previous-matching-input-from-input
       "<down>" 'comint-next-matching-input-from-input
       "<return>" 'comint-send-input)
   #+END_SRC

   Default to postgres

   #+BEGIN_SRC emacs-lisp
     (setq sql-product 'postgres)
   #+END_SRC

   Truncate lines for wide result sets

   #+BEGIN_SRC emacs-lisp
     (add-hook 'sql-interactive-mode-hook (lambda () (toggle-truncate-lines t)))
   #+END_SRC

   Enable the window movement bindings in sql shell buffers

   #+BEGIN_SRC emacs-lisp
     (keys 'sql-interactive-mode-map
       "C-j" 'evil-window-down)
   #+END_SRC

   Add some of the used brightmotive connections

   #+BEGIN_SRC emacs-lisp
     (setq sql-connection-alist
           '((tc_dev     (sql-product 'postgres)
                         (sql-port 5432)
                         (sql-server "localhost")
                         (sql-user "yannvanhalewyn")
                         (sql-database "brightmotive_tc"))
             (brezan_dev (sql-product 'postgres)
                         (sql-port 5432)
                         (sql-server "localhost")
                         (sql-user "yannvanhalewyn")
                         (sql-database "brightmotive_brezan"))
             (brightlocal_dev (sql-product 'postgres)
                              (sql-port 5432)
                              (sql-server "localhost")
                              (sql-user "yannvanhalewyn")
                              (sql-server "localhost")
                              (sql-database "brightlocal_development"))))
   #+END_SRC

** Shell

    The shell is pretty damn useful in emacs. Just some bindings:

    #+BEGIN_SRC emacs-lisp
      (keys-l :keymaps 'shell-mode-map "s k" 'erase-buffer)
      (general-def shell-mode-map
        "<up>" 'comint-previous-input
        "<down>" 'comint-next-input)
    #+END_SRC
** Make

   #+BEGIN_SRC emacs-lisp
     (keys :states 'insert :keymaps 'makefile-mode-map
       "<tab>" (lambda () (interactive) (insert-tab)))
   #+END_SRC
** Rust
   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :defer t)
   #+END_SRC
