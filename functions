#
# 8 8888888888   8 8888      88 b.             8     ,o888888o.8888888 8888888888 d888888o.
# 8 8888         8 8888      88 888o.          8    8888     `88.    8 8888     .`8888:' `88.
# 8 8888         8 8888      88 Y88888o.       8 ,8 8888       `8.   8 8888     8.`8888.   Y8
# 8 8888         8 8888      88 .`Y888888o.    8 88 8888             8 8888     `8.`8888.
# 8 888888888888 8 8888      88 8o. `Y888888o. 8 88 8888             8 8888      `8.`8888.
# 8 8888         8 8888      88 8`Y8o. `Y88888o8 88 8888             8 8888       `8.`8888.
# 8 8888         8 8888      88 8   `Y8o. `Y8888 88 8888             8 8888        `8.`8888.
# 8 8888         ` 8888     ,8P 8      `Y8o. `Y8 `8 8888       .8'   8 8888    8b   `8.`8888.
# 8 8888           8888   ,d8P  8         `Y8o.`    8888     ,88'    8 8888    `8b.  ;8.`8888
# 8 8888            `Y88888P'   8            `Yo     `8888888P'      8 8888     `Y8888P ,88P'

# Create a new directory and enter it
function md() {
  mkdir -p "$@" && cd "$@"
}


# find shorthand
function f() {
    mdfind -onlyin ./ -name "$1"
    #find . -name "$1"
}


# cd into forefront finder window
cdf() {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# Print the forefront finder window
function pwf() {
  osascript 2>/dev/null <<EOF
    tell application "Finder"
      return POSIX path of (target of window 1 as alias)
    end tell
EOF
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}"
  open "http://localhost:${port}/"
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}


# Copy w/ progress
cp_p () {
  rsync -WavP --human-readable --progress $1 $2
}


# Syntax-highlight JSON strings or files
function json() {
  if [ -p /dev/stdin ]; then
    # piping, e.g. `echo '{"foo":42}' | json`
    python -mjson.tool | pygmentize -l javascript
  else
    # e.g. `json '{"foo":42}'`
    python -mjson.tool <<< "$*" | pygmentize -l javascript
  fi
}




# get gzipped size
function gz() {
  echo "orig size    (bytes): "
  cat "$1" | wc -c
  echo "gzipped size (bytes): "
  gzip -c "$1" | wc -c
}

# whois a domain or a URL
function whois() {
  local domain=$(echo "$1" | awk -F/ '{print $3}') # get domain from URL
  if [ -z $domain ] ; then
    domain=$1
  fi
  echo "Getting whois record for: $domain …"

  # avoid recursion
          # this is the best whois server
                          # strip extra fluff
  /usr/bin/whois -h whois.internic.net $domain | sed '/NOTICE:/q'
}



# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
function extract() {
  if [ -f "$1" ] ; then
    local filename=$(basename "$1")
    local foldername="${filename%%.*}"
    local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
    local didfolderexist=false
    if [ -d "$foldername" ]; then
      didfolderexist=true
      read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
      echo
      if [[ $REPLY =~ ^[Nn]$ ]]; then
        return
      fi
    fi
    mkdir -p "$foldername" && cd "$foldername"
    case $1 in
      *.tar.bz2) tar xjf "$fullpath" ;;
      *.tar.gz) tar xzf "$fullpath" ;;
      *.tar.xz) tar Jxvf "$fullpath" ;;
      *.tar.Z) tar xzf "$fullpath" ;;
      *.tar) tar xf "$fullpath" ;;
      *.taz) tar xzf "$fullpath" ;;
      *.tb2) tar xjf "$fullpath" ;;
      *.tbz) tar xjf "$fullpath" ;;
      *.tbz2) tar xjf "$fullpath" ;;
      *.tgz) tar xzf "$fullpath" ;;
      *.txz) tar Jxvf "$fullpath" ;;
      *.zip) unzip "$fullpath" ;;
      *) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# turn that video into webm.
# brew reinstall ffmpeg --with-libvpx
webmify(){
  ffmpeg -i $1 -vcodec libvpx -acodec libvorbis -isync -copyts -aq 80 -threads 3 -qmax 30 -y $2 $1.webm
}


# Open a file in Google Chrome
chrome() {
  open -a /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome $1
}

# Open a file in FireFox
firefox() {
  open -a /Applications/Firefox.app/Contents/MacOS/firefox $1
}

# Allows to write commit messages without the quotes (thanks Orenstein - http://www.github.com/r00k)
function gc {
  git commit -m "$*"
}

# Visit git's origin page, sed will replace any SSH link to a browser url (git open)
function gopen {
  open $(git config --get remote.origin.url | sed -E s#git@\(.+\):\(.+\)#http://www.\\1/\\2#)
}

# go to the node-docs of current node version
node-docs () {
  local open_cmd
  if [[ "$OSTYPE" = darwin* ]]
  then
    open_cmd='open'
  else
    open_cmd='xdg-open'
  fi
  $open_cmd "http://nodejs.org/docs/$(node --version)/api/all.html#all_$1"
}

# print out the path of a given file
function printpath {
  if (($# == 0)); then
    pwd
  else
    echo $(cd $(dirname $1); pwd)/$(basename $1)
  fi
}

function copypath {
  if [ "$TMUX" ]; then
    local attach='reattach-to-user-namespace'
  fi
  local filepath=$(printpath $1)
  echo $filepath | $attach pbcopy
  echo "Copied '$filepath' to clipboard"
}

# Search through history
function hs {
  history | grep $*
}

# Symbolic link to realpath of file
function link {
  ln -s $(realpath "$1") "$2"
}

# Follow binary symlinks
function where {
  realpath $(which "$1")
}

function goto {
  cd $(dirname $(where "$1"))
}

function realpath() {
  for f in "$@"; do echo ${f}(:A); done
}

